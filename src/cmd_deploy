#! /bin/bash

# doc cmd_deploy {
#
# DESCRIPTION
#   cmd_deploy - Command that deploys IMAGEIDs using deploy_imageid function
#
# USAGE
#   cmd_deploy - </path/to/git/dir> </path/to/target> 
#
# }

cmd_deploy() {
    local GIT_DIR="${1}"
    local TARGET="${2}"; shift 2
    local ERR=false
    local DB_FILE="${TARGET}/${_OPT_DB_FILE}"
    [[ ! -f "${DB_FILE}" ]] && return 1

    if [[ -z "$(grep LAST_DEPLOY ${DB_FILE})" ]]; then
        echo -e "LAST_DEPLOY\t$(git -C "${GIT_DIR}" rev-list HEAD | tail -n 1)" >> ${DB_FILE}
    fi

    local NEW_COMMIT=$(git -C "${GIT_DIR}" rev-parse HEAD)
    local OLD_COMMIT=$(awk 'BEGIN{FS="\t"}{if($1=="LAST_DEPLOY"){print $2}}' ${DB_FILE})
    local removableidList=($(awk 'BEGIN{FS="\t"}{if(($1=="false" && $1=="null") && $4!="null"){print $2"--"$3}}' "${DB_FILE}"))
    local deployableidList=($(awk 'BEGIN{FS="\t"}{if($1=="true" && $4=="null"){print $2}}' "${DB_FILE}" | awk '!seen[$0]++'))
    local changedidList=($(sed 's/\(.*\)\..*/\1/' <<< $(git -C "${GIT_DIR}" diff --name-only ${NEW_COMMIT} ${OLD_COMMIT}) | awk '!seen[$0]++' | grep SHA256))
    local updateableidList=($(printf "%s\n" ${deployableidList[@]} ${changedidList[@]} | awk '!seen[$0]++'))

    # Checks if target has enough space
    local futureidList=($(awk 'BEGIN{FS="\t"}{if($1=="true"){print $2}}' ${DB_FILE} | awk '!seen[$0]++'))
    local presentidList=($(awk 'BEGIN{FS="\t"}{if($1=="true" && $4!="null"){print $2}}' ${DB_FILE} | awk '!seen[$0]++'))
    local DU="$(( $(print_imageid_du ${GIT_DIR} ${futureidList[@]}) - $(print_imageid_du "${GIT_DIR}" ${presentidList[@]}) ))"
    local DF="$(df ${TARGET} --output=avail -B1 | tail -n -1)"
    [[ ${DU} -ge ${DF} ]] && { _msg ECHO "Target does not have enough space for deployable IMAGEID. Need ${DU}, has ${DF}."; return 2; }

    # Cleans target of removable TRACKID
    local COUNT=1
    for removableid in ${removableidList[@]}; do
        echo "[ ${COUNT} / ${#removableidList[@]} ] Removing ${removableid} from ${TARGET}" 
        deploy_rm "${TARGET}" "${DB_FILE}" ${removableid} >${STDERR} 2>&1
        [[ $? -eq 0 ]] && { _ansi up 2; echo -en '\033[K'; }  || { echo "[>>>>>>] Error reported"; cat ${STDERR}; local ERR=true; }
        local COUNT=$(( ${COUNT} + 1 ))
    done
    
    local COUNT=0
    for imageid in ${updateableidList[@]}; do
        local COUNT=$(( ${COUNT} + 1 ))
        echo "[ ${COUNT} / ${#updateableidList[@]} ] Deploying ${imageid} to ${TARGET}"
        # Processes deployableids (IMAGEIDs that have TRACKIDs that are not present in target, but are selected)
        if _if_array_contains ${imageid} ${deployableidList[@]}; then
            deploy_cp "${GIT_DIR}" "${TARGET}" "${DB_FILE}" ${imageid} > ${STDERR} 2>&1
            [[ $? -eq 0 ]] || { echo "[>>>>>>] Error reported"; cat ${STDERR}; local ERR=true; continue; } 
        fi
        

        # Processes metadata changes
        deploy_meta "${GIT_DIR}" "${TARGET}" "${DB_FILE}" ${imageid} >${STDERR} 2>&1
        [[ $? -eq 0 ]] && { _ansi up 2; echo -en '\033[K'; } || { echo "[>>>>>>] Error reported"; cat ${STDERR}; local ERR=true; }
    done

    [[ "${ERR}" == "true" ]] && return 1 || { gawk -i inplace -v newcommit=${NEW_COMMIT} 'BEGIN{FS="\t";OFS="\t"}{if($1=="LAST_DEPLOY"){$2=newcommit}{print $0}}' ${DB_FILE}; return 0; }

}
